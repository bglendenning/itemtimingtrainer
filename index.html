<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="author" content="Brandan Glendenning">
    <meta name="description" content="Arena FPS item timing trainer.">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Item Timing Trainer</title>

    <link rel="icon" href="data:,">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300..700&display=swap">

    <style>
      :root {
        --color-yellow: #f5bc6c;
        --color-green: #5f8258;
        --color-red: #c95b51;
        --color-blue: #5a70a0;
        --color-white: #fff7eb;
        --color-grey: #707070;
        --color-dark-grey: #303030;
        --color-light-grey: #A0A0A0;
        --color-black: #040404;
      }

      html {
        box-sizing: border-box;
      }

      *, *:before, *:after {
        box-sizing: inherit;
      }

      body {
        background-color: var(--color-black);
        color: var(--color-light-grey);
        font-family: "Quicksand", sans-serif;
        margin: 0;
      }

      a {
        color: var(--color-white);
        font-weight: 500;
        text-decoration: none;
      }

      .item {
        border-radius: 5px;
        color: var(--color-black);
        cursor: pointer;
        font-weight: bold;
        height: 80px;
        width: 80px;
        padding: 10px;
      }

      .item:hover, a:hover {
        opacity: 0.8;
      }

      #container {
        display: flex;
        flex-flow: column;
        align-items: center;
        gap: 20px;
        height: 100vh;
      }

      #logHeader {
        display: flex;
        flex-flow: row;
        width: 50vw;
        min-width: 400px;
      }

      #logHeader div {
        width: 100%;
      }

      #logs {
        border-top: 1px var(--color-grey) dashed;
        flex: 1;
        overflow: auto;
        width: 50vw;
        min-width: 400px;
      }

      #targetForm {
        text-align: center;
      }

      #target {
        background-color: var(--color-green);
        border-radius: 50%;
        cursor: pointer;
        position: absolute;
        z-index: 1;
      }

      #timer {
        font-size: 50px;
      }

      #items {
        display: flex;
        flex-flow: row wrap;
        gap: 20px;
        justify-content: center;
      }

      #timerDisplay, #timerAdmin {
        text-align: center;
      }

      .color-yellow {
        color: var(--color-yellow);
      }

      .color-green {
        color: var(--color-green);
      }

      .color-red {
        color: var(--color-red);
      }

      .color-blue {
        color: var(--color-blue);
      }

      .color-white {
        color: var(--color-white);
      }

      .color-grey {
        color: var(--color-grey);
      }

      .background-color-yellow {
        background-color: var(--color-yellow);
      }

      .background-color-green {
        background-color: var(--color-green);
      }

      .background-color-red {
        background-color: var(--color-red);
      }

      .background-color-blue {
        background-color: var(--color-blue);
      }

      .background-color-white {
        background-color: var(--color-white);
      }

      .background-color-grey {
        background-color: var(--color-grey);
      }
    </style>
  </head>

  <body>
    <div id="target"></div>

    <div id="container">
      <div id="timer">
        <div id="timerAdmin">
          <a href="javascript:void(0)" id="timerStart">start</a>
          <a href="javascript:void(0)" id="timerStop">stop</a>
          <a href="javascript:void(0)" id="timerReset">reset</a>
          <a href="javascript:void(0)" id="timerMultiplierDecrease">-</a>
          <a href="javascript:void(0)" id="timerMultiplierIncrease">+</a>
        </div>

        <div id="timerDisplay">
          <span id="timerClock">00:00</span>
          <span id="timerMultiplier">1</span>x
        </div>
      </div>

      <div id="items"></div>

      <div id="targetForm">
        <label><input type="checkbox" id="targetToggle"> Enable randomized target</label>
      </div>

      <div id="logHeader">
        <div>High Score: <span id="scoreHigh"></span></div>

        <div style="text-align: center;">Session Score: <span id="scoreSession"></span></div>

        <div style="text-align: right;">
          <a id="clearLogs" href="javascript:void(0)">Clear Logs</a>
        </div>
      </div>

      <div id="logs">
        <p>
          Each colored square represents an arena FPS <i>item</i>. When a session is started, each
          item is interactive, representing that the item can be <i>picked up</i>. Clicking an item
          represents picking that item up during a match. Each item displays the duration for which
          the item will become non-interactive after being picked up, representing the item's
          <i>respawn delay</i>. The number of points scored for picking up an item is the difference
          between the item's respawn delay value and the time after which the item spawned that the
          item was picked up. Points are multiplied by the timescale multiplier value. It is
          possible to score negative points.
        </p>

        <p>
          <strong>Start</strong> begins or continues a stopped session. <strong>-</strong> &
          <strong>+</strong> manipulate the rate at which the timer elapses. <strong>Stop</strong>
          pauses the timer. <strong>Reset</strong> ends the session, sets the session score to 0,
          and resets the target to its original position.
        </p>

        <p>
          Check <strong>Enable randomized target</strong> to make the randomized target visible.
          Each target clicked is worth 1 point. Points are multiplied by the timescale multiplier
          value.
        </p>
      </div>
    </div>
  </body>

  <script type="text/javascript">
    /** Convert `number` to string `paddedValue` and left-pad with zeroes to length `length` */
    function pad(number, length) {
      let paddedValue = number.toString();

      while (paddedValue.length < length) {
        paddedValue = "0" + paddedValue;
      }

      return paddedValue;
    }

    /** Manipulate DOM elements related to interacting with and presenting the logger. */
    class Logger {
      constructor(timer) {
        // For rendering timestamps in log entries
        this.timer = timer;

        // DOM elements
        this.elements = {
          logs: document.getElementById("logs"),
          clear: document.getElementById("clearLogs"),
        };

        // Event listeners
        this.elements.clear.addEventListener("click", this.clearElementClick);
      }

      /** Create and style a paragraph element, then prepend it to the logs DOM element. */
      createLogEntry(content, color) {
        const paragraphElement = document.createElement("p");
        paragraphElement.textContent = `${this.timer.formatTime()} - ${content}`;
        paragraphElement.classList.add(color);
        this.elements.logs.prepend(paragraphElement);
      }

      /** Clear logs DOM element. */
      clearElementClick = () => {
        this.elements.logs.textContent = "";
      }
    }

    /**
     * Track time and manipulate DOM elements related to interacting with and presenting the
     * timer.
     */
    class Timer {
      constructor() {
        // DOM elements
        this.elements = {
          clock: document.getElementById("timerClock"),
          start: document.getElementById("timerStart"),
          stop: document.getElementById("timerStop"),
          reset: document.getElementById("timerReset"),
          multiplier: document.getElementById("timerMultiplier"),
          multiplierDecrease: document.getElementById("timerMultiplierDecrease"),
          multiplierIncrease: document.getElementById("timerMultiplierIncrease"),
        };

        this.seconds = 0;
        this.interval = false;
        this.multiplier = 1;

        // Event listeners
        this.elements.start.addEventListener("click", this.startElementClick);
        this.elements.stop.addEventListener("click", this.stopElementClick);
        this.elements.reset.addEventListener("click", this.resetElementClick);
        this.elements.multiplierDecrease.addEventListener("click", this.multiplierDecreaseElementClick);
        this.elements.multiplierIncrease.addEventListener("click", this.multiplierIncreaseElementClick);
      }

      /** The session's elapsed seconds. Used to render the clock and validate item clicks. */
      #seconds;

      get seconds() {
        return this.#seconds;
      }

      set seconds(seconds) {
        this.#seconds = seconds;
        this.updateClockElementText();
      }

      updateClockElementText() {
        this.elements.clock.textContent = this.formatTime();
      }

      /** A `setInterval` object or `null`. Used to track the session's elapsed seconds. */
      #interval;

      get interval() {
        return this.#interval;
      }

      set interval(interval) {
        if (this.interval) {
          clearInterval(this.interval);
        }

        this.#interval = interval ? setInterval(() => this.seconds += 1, (1000 / this.multiplier)) : null;
      }

      /** An integer factor used to increase or decrease the `setInterval` `delay` parameter. */
      #multiplier;

      get multiplier() {
        return this.#multiplier;
      }

      set multiplier(multiplier) {
        if (multiplier > 0) {
          this.#multiplier = multiplier;
          this.updateMultiplierElementText();
        }
      }

      updateMultiplierElementText() {
        this.elements.multiplier.textContent = this.multiplier;
      }

      /**
       * Calculate minutes and remainder seconds of `this.seconds`, pad both, and return a
       * formatted time string.
       */
      formatTime() {
        const minutes = pad(Math.floor(this.seconds / 60), 2);
        const seconds = this.seconds >= 60 ? pad(this.seconds % 60, 2) : pad(this.seconds, 2);

        return `${minutes}:${seconds}`;
      }

      /** Start the session. */
      startElementClick = () => {
        if (!this.interval) {
          this.interval = true;
        }
      }

      /** Stop the session. */
      stopElementClick = () => {
        if (this.interval) {
          this.interval = false;
        }
      }

      /** Reset the session. */
      resetElementClick = () => {
        if (this.interval) {
          this.interval = false;
        }

        this.seconds = 0;
        this.multiplier = 1;
      }

      /** Increase the interval delay by decreasing the multiplier factor. */
      multiplierDecreaseElementClick = () => {
        this.multiplier -= 1;

        // Put new multiplier into effect by updating `this.interval` if the session is active
        if (this.interval) {
          this.interval = true;
        }
      }

      /** Decrease the interval delay by increasing the multiplier factor. */
      multiplierIncreaseElementClick = () => {
        this.multiplier += 1

        // Put new multiplier into effect by updating `this.interval` if the session is active
        if (this.interval) {
          this.interval = true;
        }
      }
    }

    /**
     * Track the score and manipulate DOM elements related to interacting with and presenting the
     * score.
     */
    class Score {
      // The string length to pad scores to
      length = 10;

      constructor(timer) {
        this.timer = timer;

        // DOM elements
        this.elements = {
          session: document.getElementById("scoreSession"),
          high: document.getElementById("scoreHigh"),
          multiplier: document.getElementById("scoreMultiplier")
        };

        this.high = 0;
        this.session = 0;

        // Event listeners
        this.timer.elements.reset.addEventListener("click", () => this.session = 0);
      }

      /** An integer used to track the greatest session score. */
      #high;

      get high() {
        return this.#high;
      }

      set high(score) {
        this.#high = score;
        this.updateHighElementText();
      }

      updateHighElementText() {
        this.elements.high.textContent = pad(this.high, this.length);
      }

      /** An integer used to track the session score. */
      #session;

      get session() {
        return this.#session;
      }

      set session(points) {
        this.#session = points;
        this.updateSessionElementText();

        if (this.#session > this.high) {
          this.high = this.#session;
        }
      }

      /** Multiply `points` by `timer.multiplier` and add to the session score. */
      addPointsToSessionScore(points) {
        this.session += points * this.timer.multiplier
      }

      updateSessionElementText() {
        this.elements.session.textContent = pad(this.session, this.length);
      }
    }

    /** Manipulate DOM elements related to interacting with and presenting the target. */
    class Target {
      defaults = {
        left: 50, // Target DOM left position in pixels
        top: 50, // Target DOM top position in pixels
        side: 25, // Target DOM width and height dimensions in pixels
      }
      pointValue = 1;

      constructor(timer, score) {
        this.timer = timer;
        this.score = score;

        // DOM elements
        this.elements = {
          target: document.getElementById("target"),
          targetToggle: document.getElementById("targetToggle"),
        };

        this.targetElementLeft = this.defaults.left;
        this.targetElementTop = this.defaults.top;
        this.targetElementWidth = this.defaults.side;
        this.targetElementHeight = this.defaults.side;
        this.targetElementVisibility = this.elements.targetToggle;

        // Event listeners
        this.elements.target.addEventListener("click", this.targetElementClick);
        this.elements.targetToggle.addEventListener("click", this.targetToggleElementClick);
        this.timer.elements.reset.addEventListener("click", this.resetTargetElementPosition);
        this.timer.elements.reset.addEventListener("click", this.resetTargetElementDimensions);
      }

      /** The left position, in pixels, of the target DOM element */
      #targetElementLeft;

      get targetElementLeft() {
        return this.#targetElementLeft;
      }

      set targetElementLeft(left) {
        this.#targetElementLeft = left;
        this.updateTargetElement();
      }

      /** The top position, in pixels, of the target DOM element */
      #targetElementTop;

      get targetElementTop() {
        return this.#targetElementTop;
      }

      set targetElementTop(top) {
        this.#targetElementTop = top;
        this.updateTargetElement();
      }

      /** The width, in pixels, of the target DOM element */
      #targetElementWidth;

      get targetElementWidth() {
        return this.#targetElementWidth;
      }

      set targetElementWidth(width) {
        this.#targetElementWidth = width;
        this.updateTargetElement();
      }

      /** The height, in pixels, of the target DOM element */
      #targetElementHeight;

      get targetElementHeight() {
        return this.#targetElementHeight;
      }

      set targetElementHeight(height) {
        this.#targetElementHeight = height;
        this.updateTargetElement();
      }

      /** The CSS `visibility` of the target DOM element */
      #targetElementVisibility;

      get targetElementVisibility() {
        return this.#targetElementVisibility;
      }

      set targetElementVisibility(targetToggleElement) {
        this.#targetElementVisibility = targetToggleElement.checked ? "visible" : "hidden";
        this.updateTargetElement();
      }

      updateTargetElement() {
        this.elements.target.style.left = `${this.targetElementLeft}px`;
        this.elements.target.style.top = `${this.targetElementTop}px`;
        this.elements.target.style.width = `${this.targetElementWidth}px`;
        this.elements.target.style.height = `${this.targetElementHeight}px`;
        this.elements.target.style.visibility = this.targetElementVisibility;
      }

      resetTargetElementPosition = () => {
        this.targetElementLeft = this.defaults.left;
        this.targetElementTop = this.defaults.top;
      }

      resetTargetElementDimensions = () => {
        this.targetElementWidth = this.defaults.side;
        this.targetElementHeight = this.defaults.side;
      }

      setRandomTargetElementPositions() {
        const maxLeft = window.innerWidth - this.targetElementWidth * 2;
        const maxTop = window.innerHeight - this.targetElementHeight * 2;
        this.targetElementLeft = Math.floor((Math.random() * maxLeft) + this.targetElementWidth);
        this.targetElementTop = Math.floor((Math.random() * maxTop) + this.targetElementHeight);
      }

      setRandomTargetElementDimensions() {
        const value = Math.floor((Math.random() * this.defaults.side) + this.defaults.side * 1.5);
        this.targetElementWidth = value;
        this.targetElementHeight = value;
      }

      /**
       * Set the target DOM element to a random position in the browser window and add to the
       * session score.
       */
      targetElementClick = () => {
        if (this.timer.interval && this.elements.targetToggle.checked) {
          this.setRandomTargetElementDimensions();
          this.setRandomTargetElementPositions();
          this.score.addPointsToSessionScore(this.pointValue);
        }
      }

      targetToggleElementClick = (event) => {
        this.targetElementVisibility = event.target;
      }
    }

    /**
     * Track items and manipulate DOM elements related to interacting with and presenting items.
     */
    class Items {
      constructor(timer, logger, score) {
        this.timer = timer;
        this.logger = logger;
        this.score = score;

        // DOM elements
        this.elements = {
          items: document.getElementById("items"),
        }

        this.items = [
          {
            presentationName: "Red Armor",
            domElementId: "itemArmorRed",
            spawnIntervalSeconds: 25,
            spawnTimeSeconds: 0,
            backgroundColorClass: "background-color-red",
            logTextColorClass: "color-red"
          },
          {
            presentationName: "Yellow Armor",
            domElementId: "itemArmorYellow",
            spawnIntervalSeconds: 25,
            spawnTimeSeconds: 0,
            backgroundColorClass: "background-color-yellow",
            logTextColorClass: "color-yellow"
          },
          {
            presentationName: "Megahealth",
            domElementId: "itemHealthMega",
            spawnIntervalSeconds: 35,
            spawnTimeSeconds: 0,
            backgroundColorClass: "background-color-blue",
            logTextColorClass: "color-blue"
          },
        ];

        // Event listeners
        this.timer.elements.reset.addEventListener("click", this.resetElementClick);
      }

      /**
       * An array of item objects containing information. Used to manipulate the DOM and track
       * item interactivity.
       */
      #items;

      get items() {
        return this.#items;
      }

      set items(items) {
        this.#items = items;
        this.createItemsDomElements(items);
      }

      /**
       * Create a DOM element for each item in `items`, style the element, then create an
       * `EventListener` for the element.
       */
      createItemsDomElements(items) {
        items.forEach((item) => {
          const element = document.createElement("div");
          element.setAttribute("id", item.domElementId);
          element.classList.add("item", item.backgroundColorClass);
          element.textContent = item.spawnIntervalSeconds;
          this.elements.items.append(element);
          element.addEventListener("click", this.itemElementClick);
        });
      }

      /**
       * Determine if the item clicked is interactive, and, if it is, add the item's point value
       * to the session score, then log the click, else log the early click.
       */
      itemElementClick = (event) => {
        if (this.timer.interval) {
          // Find the item in `this.items` using the event target element's ID
          const item = this.items.find((item) => item.domElementId === event.target.getAttribute("id"));
          const difference = this.timer.seconds - item.spawnTimeSeconds;

          // The item element is interactive
          if (difference >= 0) {
            // The time, in seconds, at which the item will be interactive
            item.spawnTimeSeconds = this.timer.seconds + item.spawnIntervalSeconds;
            this.score.addPointsToSessionScore(item.spawnIntervalSeconds - difference);
            this.logger.createLogEntry(
              `${item.presentationName} clicked ${difference} seconds after spawn`,
              item.logTextColorClass
            );
          // The item element is not interactive
          } else {
            this.logger.createLogEntry(
              `${item.presentationName} pick-up attempted ${Math.abs(difference)} seconds before spawn`,
              "color-grey"
            );
          }
        }
      }

      resetItemsDomElementInnerHtml() {
        this.elements.items.textContent = "";
      }

      /**
       * Clear the items DOM element, reset each item's `spawnTimeSeconds` so that the items are
       * interactive when a new session starts, then set `this.items` with the updated items.
       */
      resetElementClick = () => {
        this.resetItemsDomElementInnerHtml();
        // Create a deep copy of `this.items`
        const items = structuredClone(this.items);

        items.forEach((item) => {
          item.spawnTimeSeconds = 0;
        });

        this.items = items;
      }
    }

    const timer = new Timer();
    const score = new Score(timer);
    const logger = new Logger(timer);
    const target = new Target(timer, score);
    const items = new Items(timer, logger, score);
  </script>
</html>
