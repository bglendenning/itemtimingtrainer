<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="author" content="Brandan Glendenning">
    <meta name="description" content="Arena FPS item timing trainer.">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Item Timing Trainer</title>

    <link rel="icon" href="data:,">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300..700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Quicksand:wght@300..700&display=swap">

    <style>
      :root {
        --color-yellow: #f5bc6c;
        --color-green: #5f8258;
        --color-red: #c95b51;
        --color-blue: #5a70a0;
        --color-white: #fff7eb;
        --color-grey: #707070;
        --color-light-grey: #A0A0A0;
        --color-black: #040404;
        --color-black-transparent: rgb(4 4 4 / 55%);
      }

      html {
        box-sizing: border-box;
      }

      *, *:before, *:after {
        box-sizing: inherit;
      }

      body {
        background-image: url("images/background.webp");
        background-size: cover;
        color: var(--color-light-grey);
        font-family: "Quicksand", sans-serif;
        margin: 0;
      }

      a {
        color: var(--color-white);
        font-weight: 500;
        text-decoration: none;
      }

      em {
        color: var(--color-white);
        font-weight: 500;
      }

      h1 {
          font-size: 1.5em;
      }

      h2 {
          font-size: 1.1em;
      }

      /* Target */

      #target {
        background-color: var(--color-green);
        border-radius: 50%;
        cursor: pointer;
        filter: drop-shadow(0 0 10px var(--color-white));
        position: absolute;
        z-index: 1;
      }

      /* General */

      #container {
        background-color: var(--color-black-transparent);
        display: flex;
        flex-flow: column;
        align-items: center;
        gap: 20px;
        height: 100vh;
        padding: 20px;
      }

      /* Items */

      #items {
        display: flex;
        flex-flow: row wrap;
        gap: 20px;
        justify-content: center;
      }

      .item {
        background-size: 50%;
        background-repeat: no-repeat;
        background-position: center;
        border-top-right-radius: 10%;
        border-bottom-right-radius: 10%;
        border-bottom-left-radius: 10%;
        border: 3px var(--color-white) solid;
        color: var(--color-white);
        cursor: pointer;
        font-weight: bold;
        height: 15vh;
        min-height: 80px;
        width: 15vh;
        min-width: 80px;
        padding: 10px;
      }

      a:hover, .item:hover {
        opacity: 0.8;
      }

      /* Logs */

      #logsHeader {
        background-color: var(--color-black-transparent);
        display: flex;
        flex-flow: row;
        padding: 15px;
        width: 50vw;
        min-width: 400px;
      }

      #logsHeader div {
        width: 100%;
      }

      #content {
        background-color: var(--color-black-transparent);
        border-top: 1px var(--color-black) dashed;
        flex: 1;
        overflow: auto;
        padding: 0 15px;
        width: 50vw;
        min-width: 400px;
      }

      #logs > p.entry {
          font-family: "JetBrains Mono", monospace;
          margin: 0;
      }

      #logs > p.entry:first-child {
          margin-top: revert;
      }

      /* Color classes */

      .color-yellow {
        color: var(--color-yellow);
      }

      .color-green {
        color: var(--color-green);
      }

      .color-red {
        color: var(--color-red);
      }

      .color-blue {
        color: var(--color-blue);
      }

      .color-white {
        color: var(--color-white);
      }

      .color-grey {
        color: var(--color-grey);
      }

      .background-color-yellow {
        background-color: var(--color-yellow);
      }

      .background-color-green {
        background-color: var(--color-green);
      }

      .background-color-red {
        background-color: var(--color-red);
      }

      .background-color-blue {
        background-color: var(--color-blue);
      }

      .background-color-white {
        background-color: var(--color-white);
      }

      .background-color-grey {
        background-color: var(--color-grey);
      }

      /* Utility classes */

      .text-center {
        text-align: center;
      }

      .text-right {
        text-align: right;
      }

      .text-large {
          font-size: 2.5em;
      }

      .text-larger {
          font-size: 4em;
      }
    </style>
  </head>

  <body>
    <div id="target"></div>

    <div id="container">
      <div class="text-center text-large">
        <a href="javascript:void(0)" id="timerStart">Start</a>
        <a href="javascript:void(0)" id="timerPause">Pause</a>
        <a href="javascript:void(0)" id="timerEnd">End</a>
        <a href="javascript:void(0)" id="timerMultiplierDecrease">-</a>
        <a href="javascript:void(0)" id="timerMultiplierIncrease">+</a>
      </div>

      <div class="text-center text-larger">
        <span id="timerClock">00:00</span>
        <span id="timerMultiplier">1</span>x
      </div>

      <div id="items"></div>

      <div class="text-center">
        <label><input type="checkbox" id="targetToggle"> Enable randomized target</label>
      </div>

      <div id="logsHeader">
        <div>High: <span id="scoreHigh"></span></div>

        <div class="text-center">Session: <span id="scoreSession"></span></div>

        <div class="text-right">Avg. Click: <span id="clickSession"></span>ms</div>
      </div>

      <div id="content">
        <div class="text-right">
          <a id="clearLogs" href="javascript:void(0)">Clear Logs</a>
        </div>

        <div id="logs"></div>

        <h1>Arena FPS Item Timing Trainer</h1>
        <h2>
          By Brandan Glendenning (<a href="https://github.com/bglendenning/itemtimingtrainer" target="new">GitHub</a>)
        </h2>

        <p>
          When a session is started, each <em>item</em> <sup>(colored square)</sup> <em>spawns</em>
          <sup>(becomes interactive)</sup> immediately. <em>Picking up</em> <sup>(clicking)</sup> an
          item conditionally adds points to the session score. An item's maximum points value is
          equal to its <em>spawn delay time</em> <sup>(post-click non-interactivity interval)</sup>.
          A point is deducted from the maximum points value for each second elapsed after the item
          spawns that the item is not picked up. The maximum value that can be deducted is the
          item's spawn delay time. Points are multiplied by the timescale multiplier value before
          being added to the session score.
        </p>

        <p>
          <em>Start</em> begins or continues a paused session. <em>-</em> & <em>+</em> manipulate
          the rate at which the timer elapses. <em>Pause</em> pauses the timer. <em>End</em> ends
          the session, sets the session score to 0, and resets the target to its original position.
          Check <em>Enable randomized target</em> to display an interactive target that is assigned
          random positions and dimensions after each click. Targets clicked are worth 1 point,
          multiplied by the timescale multiplier value.
        </p>
      </div>
    </div>
  </body>

  <script type="text/javascript">
    /** Convert `number` to string `paddedValue` and left-pad with zeroes to length `length` */
    function pad(number, length) {
      let paddedValue = number.toString();

      while (paddedValue.length < length) {
        paddedValue = "0" + paddedValue;
      }

      return paddedValue;
    }

    /** Manipulate DOM elements related to interacting with and presenting the logger. */
    class Logger {
      constructor(timer) {
        // For rendering timestamps in log entries
        this.timer = timer;

        // DOM elements
        this.elements = {
          logs: document.getElementById("logs"),
          clear: document.getElementById("clearLogs"),
        };

        // Event listeners
        this.elements.clear.addEventListener("click", this.clearElementClick);
      }

      /** Create and style a paragraph element, then prepend it to the logs DOM element. */
      createLogEntry(content, color) {
        const paragraphElement = document.createElement("p");
        paragraphElement.textContent = `${this.timer.formatTime(this.timer.seconds)} - ${content}`;
        paragraphElement.classList.add(color, "entry");
        this.elements.logs.prepend(paragraphElement);
      }

      /** Clear logs DOM element. */
      clearElementClick = () => {
        this.elements.logs.textContent = "";
      }
    }

    /**
     * Track time and manipulate DOM elements related to interacting with and presenting the
     * timer.
     */
    class Timer {
      constructor() {
        // DOM elements
        this.elements = {
          clock: document.getElementById("timerClock"),
          start: document.getElementById("timerStart"),
          pause: document.getElementById("timerPause"),
          end: document.getElementById("timerEnd"),
          multiplier: document.getElementById("timerMultiplier"),
          multiplierDecrease: document.getElementById("timerMultiplierDecrease"),
          multiplierIncrease: document.getElementById("timerMultiplierIncrease"),
        };

        this.seconds = 0;
        this.interval = null;
        this.multiplier = 1;

        // Event listeners
        this.elements.start.addEventListener("click", this.startElementClick);
        this.elements.pause.addEventListener("click", this.pauseElementClick);
        this.elements.end.addEventListener("click", this.endElementClick);
        this.elements.multiplierDecrease.addEventListener("click", this.multiplierDecreaseElementClick);
        this.elements.multiplierIncrease.addEventListener("click", this.multiplierIncreaseElementClick);
      }

      /** The session's elapsed seconds. Used to render the clock and validate item clicks. */
      #seconds;

      get seconds() {
        return this.#seconds;
      }

      set seconds(seconds) {
        this.#seconds = seconds;
        this.updateClockElementText();
      }

      updateClockElementText() {
        this.elements.clock.textContent = this.formatTime(this.seconds);
      }

      /**
        * `null` if a session has not been started or has ended, a `setInterval` object if a session
        * is started, or `false` if a session is paused. Used to track the session state and elapsed
        * seconds.
        * */
      #interval;

      get interval() {
        return this.#interval;
      }

      set interval(interval) {
        clearInterval(this.interval);

        if (interval) {
          this.#interval = setInterval(() => this.seconds += 1, (1000 / this.multiplier));
        } else {
          this.#interval = interval;
        }
      }

      /** An integer factor used to increase or decrease the `setInterval` `delay` parameter. */
      #multiplier;

      get multiplier() {
        return this.#multiplier;
      }

      set multiplier(multiplier) {
        if (multiplier > 0) {
          this.#multiplier = multiplier;
          this.updateMultiplierElementText();
        }
      }

      updateMultiplierElementText() {
        this.elements.multiplier.textContent = this.multiplier;
      }

      #sessionTimes = [];

      get sessionTimes() {
        return this.#sessionTimes;
      }

      /**
       * Track the session state over time by recording consecutive start and pause times. Each
       * object contains a `start` property. An `end` property is added when the session is paused.
       * An object with both properties represents a period of time in which the session was active.
       */
      set sessionTimes(value) {
        if (Array.isArray(value)) {
          this.#sessionTimes = value;
        } else {
          if (this.#sessionTimes.length === 0) {
            // Session has been started
            this.#sessionTimes.push({start: value});
          } else {
            // Find the first session time that doesn't have an end
            const index = this.sessionTimes.findIndex((pause) => !pause.hasOwnProperty("end"));

            if (index !== -1) {
              // Since `sessionTimes[index]` doesn't have an end, the session is being paused
              this.#sessionTimes[index].end = value;
            } else {
              // Since a `sessionTimes[index]` has an end, the session is being restarted
              // Create a new session time
              this.#sessionTimes.push({start: value});
            }
          }
        }
      }

      /**
       * Calculate minutes and remainder seconds of `timerSeconds`, pad both, and return a
       * formatted time string.
       */
      formatTime(timerSeconds) {
        const minutes = pad(Math.floor(timerSeconds / 60), 2);
        const seconds = timerSeconds >= 60 ? pad(timerSeconds % 60, 2) : pad(timerSeconds, 2);

        return `${minutes}:${seconds}`;
      }

      /** Start the session. */
      startElementClick = () => {
        if (!this.interval) {
          this.interval = true;
          this.sessionTimes = performance.now();
        }
      }

      /** Pause the session. */
      pauseElementClick = () => {
        if (this.interval) {
          this.interval = false;
          this.sessionTimes = performance.now();
        }
      }

      /** End the session. */
      endElementClick = () => {
        if (this.interval) {
          this.interval = null;
        }

        this.seconds = 0;
        this.multiplier = 1;
        this.sessionTimes = [];
      }

      /** Increase the interval delay by decreasing the multiplier factor. */
      multiplierDecreaseElementClick = () => {
        this.multiplier -= 1;

        // Put new multiplier into effect by updating `this.interval` if the session is active
        if (this.interval) {
          this.interval = true;
        }
      }

      /** Decrease the interval delay by increasing the multiplier factor. */
      multiplierIncreaseElementClick = () => {
        this.multiplier += 1

        // Put new multiplier into effect by updating `this.interval` if the session is active
        if (this.interval) {
          this.interval = true;
        }
      }
    }

    /**
     * Track the score and manipulate DOM elements related to interacting with and presenting the
     * score.
     */
    class Score {
      // The string length to pad scores to
      length = 6;

      constructor(timer) {
        this.timer = timer;

        // DOM elements
        this.elements = {
          session: document.getElementById("scoreSession"),
          high: document.getElementById("scoreHigh"),
          multiplier: document.getElementById("scoreMultiplier")
        };

        this.high = 0;
        this.session = 0;

        // Event listeners
        this.timer.elements.end.addEventListener("click", () => this.session = 0);
      }

      /** An integer used to track the greatest session score. */
      #high;

      get high() {
        return this.#high;
      }

      set high(score) {
        this.#high = score;
        this.updateHighElementText();
      }

      updateHighElementText() {
        this.elements.high.textContent = pad(this.high, this.length);
      }

      /** An integer used to track the session score. */
      #session;

      get session() {
        return this.#session;
      }

      set session(points) {
        this.#session = points;
        this.updateSessionElementText();

        if (this.#session > this.high) {
          this.high = this.#session;
        }
      }

      /** Multiply `points` by `timer.multiplier` and add to the session score. */
      addPointsToSessionScore(points) {
        this.session += points * this.timer.multiplier
      }

      updateSessionElementText() {
        this.elements.session.textContent = pad(this.session, this.length);
      }
    }

    /** Manipulate DOM elements related to interacting with and presenting the target. */
    class Target {
      defaults = {
        left: 50, // Target DOM left position in pixels
        top: 50, // Target DOM top position in pixels
        side: 25, // Target DOM width and height dimensions in pixels
      }
      pointValue = 1;

      constructor(timer, score) {
        this.timer = timer;
        this.score = score;

        // DOM elements
        this.elements = {
          target: document.getElementById("target"),
          targetToggle: document.getElementById("targetToggle"),
          clickSession: document.getElementById("clickSession"),
        };

        this.targetElementLeft = this.defaults.left;
        this.targetElementTop = this.defaults.top;
        this.targetElementWidth = this.defaults.side;
        this.targetElementHeight = this.defaults.side;
        this.targetElementVisibility = this.elements.targetToggle;
        this.updateClickSessionElement();

        // Event listeners
        this.elements.target.addEventListener("click", this.targetElementClick);
        this.elements.targetToggle.addEventListener("click", this.targetToggleElementClick);
        this.timer.elements.end.addEventListener("click", this.endElementClick);
      }

      /** The left position, in pixels, of the target DOM element */
      #targetElementLeft;

      get targetElementLeft() {
        return this.#targetElementLeft;
      }

      set targetElementLeft(left) {
        this.#targetElementLeft = left;
        this.updateTargetElement();
      }

      /** The top position, in pixels, of the target DOM element */
      #targetElementTop;

      get targetElementTop() {
        return this.#targetElementTop;
      }

      set targetElementTop(top) {
        this.#targetElementTop = top;
        this.updateTargetElement();
      }

      /** The width, in pixels, of the target DOM element */
      #targetElementWidth;

      get targetElementWidth() {
        return this.#targetElementWidth;
      }

      set targetElementWidth(width) {
        this.#targetElementWidth = width;
        this.updateTargetElement();
      }

      /** The height, in pixels, of the target DOM element */
      #targetElementHeight;

      get targetElementHeight() {
        return this.#targetElementHeight;
      }

      set targetElementHeight(height) {
        this.#targetElementHeight = height;
        this.updateTargetElement();
      }

      /** The CSS `visibility` of the target DOM element */
      #targetElementVisibility;

      get targetElementVisibility() {
        return this.#targetElementVisibility;
      }

      set targetElementVisibility(targetToggleElement) {
        this.#targetElementVisibility = targetToggleElement.checked ? "visible" : "hidden";
        this.updateTargetElement();
      }

      /** Ascending click times. */
      #clickTimes = [];

      get clickTimes() {
        return this.#clickTimes;
      }

      set clickTimes(value) {
        if (Array.isArray(value)) {
          this.#clickTimes = value;
        } else {
          this.#clickTimes.push(value);

          if (this.clickTimes.length === 2) {
            // Generate a click interval from the two consecutive click times
            this.clickIntervals = this.clickTimes;
            // Remove the older click time to prepare for the next click time
            this.#clickTimes.splice(0, 1);
          }
        }

        this.updateClickSessionElement();
      }

      resetClickTimes() {
        this.clickTimes = [];
        this.clickIntervals = [];
        this.updateClickSessionElement();
      }

      /** The intervals, in milliseconds, between consecutive clicks */
      #clickIntervals = [];

      /** Return the average of the summed `#clickIntervals` in milliseconds or 0. */
      get clickIntervals() {
        let clickIntervalSum = this.#clickIntervals.reduce(
          (totalTime, recordedTime) => totalTime + recordedTime, 0
        );

        if (clickIntervalSum > 0) {
          return Math.round(clickIntervalSum / this.#clickIntervals.length);
        }

        return clickIntervalSum;
      }

      /**
       * Accept a length-2 array of consecutive click times and determine the interval between
       * them. Determine the time, if any, for which the session was paused between clicks, and
       * subtract that time from the click interval.
       */
      set clickIntervals(clickTimes) {
        if (Array.isArray(clickTimes) && clickTimes.length === 0) {
          // Reset `#clickIntervals` if `clickTimes` is empty
          this.#clickIntervals = [];
        } else {
          const pauseDuration = this.getPauseDurationBetweenClicks(clickTimes[0], clickTimes[1]);
          this.#clickIntervals.push(clickTimes[1] - clickTimes[0] - pauseDuration);
        }
      }

      updateClickSessionElement() {
        this.elements.clickSession.textContent = `${this.clickIntervals}`;
      }

      /** Sum the duration of time that the session was paused between two click times. */
      getPauseDurationBetweenClicks(startClick, endClick) {
        const sessionTimes = this.timer.sessionTimes;

        return  sessionTimes.reduce((totalTime, sessionTime, index) => {
          const nextIndex = index + 1;

          if (nextIndex in sessionTimes) {
            if (sessionTime.end > startClick && sessionTimes[index + 1].start < endClick) {
              return totalTime + sessionTimes[index + 1].start - sessionTime.end;
            }
          }

          return totalTime;
        }, 0);
      }

      updateTargetElement() {
        this.elements.target.style.left = `${this.targetElementLeft}px`;
        this.elements.target.style.top = `${this.targetElementTop}px`;
        this.elements.target.style.width = `${this.targetElementWidth}px`;
        this.elements.target.style.height = `${this.targetElementHeight}px`;
        this.elements.target.style.visibility = this.targetElementVisibility;
      }

      endElementClick = () => {
        this.resetTargetElementPosition();
        this.resetTargetElementDimensions();
        this.resetClickTimes();
      }

      resetTargetElementPosition() {
        this.targetElementLeft = this.defaults.left;
        this.targetElementTop = this.defaults.top;
      }

      resetTargetElementDimensions() {
        this.targetElementWidth = this.defaults.side;
        this.targetElementHeight = this.defaults.side;
      }

      setRandomTargetElementPositions() {
        const maxLeft = window.innerWidth - this.targetElementWidth * 2;
        const maxTop = window.innerHeight - this.targetElementHeight * 2;
        this.targetElementLeft = Math.floor((Math.random() * maxLeft) + this.targetElementWidth);
        this.targetElementTop = Math.floor((Math.random() * maxTop) + this.targetElementHeight);
      }

      setRandomTargetElementDimensions() {
        const value = Math.floor(
          Math.random() * ((this.defaults.side * 2) - (this.defaults.side / 2)) + (this.defaults.side / 2)
        );
        this.targetElementWidth = value;
        this.targetElementHeight = value;
      }

      /**
       * Set the target DOM element to a random position in the browser window and add to the
       * session score.
       */
      targetElementClick = () => {
        if (this.timer.interval && this.elements.targetToggle.checked) {
          this.clickTimes = performance.now();
          this.setRandomTargetElementDimensions();
          this.setRandomTargetElementPositions();
          this.score.addPointsToSessionScore(this.pointValue);
        }
      }

      targetToggleElementClick = (event) => {
        this.targetElementVisibility = event.target;
      }
    }

    /**
     * Track items and manipulate DOM elements related to interacting with and presenting items.
     */
    class Items {
      constructor(timer, logger, score) {
        this.timer = timer;
        this.logger = logger;
        this.score = score;

        // DOM elements
        this.elements = {
          items: document.getElementById("items"),
        }

        this.items = [
          {
            presentationName: "Red Armor",
            domElementId: "itemArmorRed",
            spawnIntervalSeconds: 25,
            spawnTimeSeconds: 0,
            backgroundColorClass: "background-color-red",
            backgroundImage: "url('images/armor.webp')",
          },
          {
            presentationName: "Yellow Armor",
            domElementId: "itemArmorYellow",
            spawnIntervalSeconds: 25,
            spawnTimeSeconds: 0,
            backgroundColorClass: "background-color-yellow",
            backgroundImage: "url('images/armor.webp')",
          },
          {
            presentationName: "Megahealth",
            domElementId: "itemHealthMega",
            spawnIntervalSeconds: 35,
            spawnTimeSeconds: 0,
            backgroundColorClass: "background-color-blue",
            backgroundImage: "url('images/megahealth.webp')",
          },
        ];

        // Event listeners
        this.timer.elements.end.addEventListener("click", this.resetElementClick);
      }

      /**
       * An array of item objects containing information. Used to manipulate the DOM and track
       * item interactivity.
       */
      #items;

      get items() {
        return this.#items;
      }

      set items(items) {
        this.#items = items;
        this.createItemsDomElements(items);
      }

      /**
       * Create a DOM element for each item in `items`, style the element, then create an
       * `EventListener` for the element.
       */
      createItemsDomElements(items) {
        items.forEach((item) => {
          const element = document.createElement("div");
          element.setAttribute("id", item.domElementId);
          element.classList.add("item", item.backgroundColorClass);
          element.style.backgroundImage = item.backgroundImage;
          element.textContent = item.spawnIntervalSeconds;
          this.elements.items.append(element);
          element.addEventListener("click", this.itemElementClick);
        });
      }

      /**
       * Determine if the item clicked is interactive, and, if it is, add the item's point value
       * to the session score, then log the click, else log the early click.
       */
      itemElementClick = (event) => {
        if (this.timer.interval) {
          // Find the item in `this.items` using the event target element's ID
          const item = this.items.find((item) => item.domElementId === event.target.getAttribute("id"));
          const spawnTimeAtClick = item.spawnTimeSeconds;
          const clickTime = this.timer.seconds;
          const difference = clickTime - item.spawnTimeSeconds;

          // The item element is interactive
          if (difference >= 0) {
            // The time, in seconds relative to the session timer, at which the item will next be interactive
            item.spawnTimeSeconds = clickTime + item.spawnIntervalSeconds;
            // Subtract a maximum of `item.spawnIntervalSeconds` points from the item points value for delayed clicks
            const points = item.spawnIntervalSeconds - Math.min(difference, item.spawnIntervalSeconds);
            let color;

            if (difference === 0) {
              color = "color-blue";
            } else if (difference <= 3) {
              color = "color-green";
            } else if (difference <= 5) {
              color = "color-yellow";
            } else {
              color = "color-red";
            }

            this.score.addPointsToSessionScore(points);
            this.logger.createLogEntry(
              `
                ${item.presentationName}: spawned at ${timer.formatTime(spawnTimeAtClick)}, ${points} points,
                ${difference} second click delay
              `,
              color
            );
          // The item element is not interactive
          } else {
            this.logger.createLogEntry(
              `${item.presentationName} clicked ${Math.abs(difference)} seconds early`, "color-grey"
            );
          }
        }
      }

      resetItemsDomElementInnerHtml() {
        this.elements.items.textContent = "";
      }

      /**
       * Clear the items DOM element, reset each item's `spawnTimeSeconds` so that the items are
       * interactive when a new session starts, then set `this.items` with the updated items.
       */
      resetElementClick = () => {
        this.resetItemsDomElementInnerHtml();
        // Create a deep copy of `this.items`
        const items = structuredClone(this.items);

        items.forEach((item) => {
          item.spawnTimeSeconds = 0;
        });

        this.items = items;
      }
    }

    const timer = new Timer();
    const score = new Score(timer);
    const logger = new Logger(timer);
    const target = new Target(timer, score);
    const items = new Items(timer, logger, score);
  </script>
</html>
